#ifndef SIMAGE_H
#define SIMAGE_H

/*
 * simage:
 *
 * A simple library for loading images. This library is designed
 * for loading textures to be used as OpenGL textures. 
 * Only pixel formats directly supported by OpenGL (v1.0) will be 
 * returned. The user is responsible for resizing the texture to
 * a 2^n width/height though.
 *
 * This library does not support the "new" OpenGL v1.1 image
 * formats. In the future this might be supported though. We still
 * have some old SGI HW with only OpenGL v1.0 installed...
 *
 * Usage information:
 *
 * simage_check_supported(filename): 
 *
 *   Will return 1 if filename can be loaded, 0 otherwise. 
 *
 * simage_read_image(filename, width, height, numComponents)
 *
 *   Will (attempt to) read filename, and return a pointer to
 *   the image data. NULL is returned if the image could not
 *   be loaded. The memory is allocated using malloc(), and
 *   it is the callers responsibility to free the memory (using free())
 *   width and height contains the width and height of the image,
 *   and numComponents is a number indicating the following:
 *     1 : Grayscale image (GL_LUMINANCE)
 *     2 : Grayscale with alpha channel (GL_LUMINANCE_ALPHA)
 *     3 : RGB data (GL_RGB)
 *     4 : RGB data with alpha component (GL_RGBA)
 *
 * int simage_check_save_supported(const char * filenameextension)
 *    
 *   Returns 1 if a saver of type filenameextension is added. The
 *   built-in savers are jpg/jpeg, png, tif/tiff and rgb.
 *
 * int simage_save_image(const char * filename,
 *                       const unsigned char * bytes,
 *                       int w, int h, int numcomponents,
 *                       const char * filenameextension)
 *
 *   Saves image in the format specified in filenameextension.
 *
 * A couple of functions for your convenience:
 *
 * simage_resize(imagedata, width, height, numComponents,
 *               newwidth, newheight)
 *
 *   A convenience function that can be used to resize an image.
 *   Since OpenGL textures must have width and height equal to 2^n,
 *   this is often needed. A pointer to the new image data is returned. 
 *   imagedata is not freed. Uses the algorithm "Filtered Image
 *   Rescaling" by Dale Schumacher, from GGems III. 
 *
 * simage_next_power_of_two(int val)
 * 
 *   Will return the first 2^n bigger or equal to val. 
 *   If simage_next_power_of_two(size) != size, you'll typically
 *   need to resize your image to be able to use it in an OpenGL app.
 */  

/* A unique identifier to recognize in sourcecode whether or not this
 * file is included.
 */
#define __SIMAGE__

/* version 1.1 introduced saving */
#define SIMAGE_VERSION_1_1

/* version 1.2 added a new API, and support for movies */
#define SIMAGE_VERSION_1_2

/* These are available for adding or omitting features based on simage
 * version numbers in "client" sources. NB: they are automatically
 * synchronized with the settings in configure.in when configure is
 * run. The #ifndefs are necessary because during development, these
 * are also defined in the config.h file generated by configure.
 */
#if !defined(SIMAGE_MAJOR_VERSION)
#undef SIMAGE_MAJOR_VERSION
#endif /* !SIMAGE_MAJOR_VERSION */
#if !defined(SIMAGE_MINOR_VERSION)
#undef SIMAGE_MINOR_VERSION
#endif /* !SIMAGE_MINOR_VERSION */
#if !defined(SIMAGE_MICRO_VERSION)
#undef SIMAGE_MICRO_VERSION
#endif /* !SIMAGE_MICRO_VERSION */
#if !defined(SIMAGE_VERSION)
#undef SIMAGE_VERSION
#endif /* !SIMAGE_VERSION */


/* Enable to generate SIMAGE.DLL (under Win32). */
#ifdef SIMAGE_MAKE_DLL
#define SIMAGE_DLL_API __declspec(dllexport)
#else
#ifdef SIMAGE_DLL
#define SIMAGE_DLL_API __declspec(dllimport)
#else
/* Empty define to avoid errors when _not_ compiling as a DLL. */
#define SIMAGE_DLL_API
#endif
#endif /* !SIMAGE_MAKE_DLL */


#ifdef __cplusplus
extern "C" {
#endif

  /* run-time version checking */
  SIMAGE_DLL_API void simage_version(int * major, int * minor, int * micro);

  /* check if image file format is supported */
  SIMAGE_DLL_API int simage_check_supported(const char * filename);

  /* reading and parsing image files */
  /* returned image buffer must be freed by simage_free_image() */
  SIMAGE_DLL_API unsigned char * simage_read_image(const char * filename,
                                                      int * w, int * h,
                                                      int * numcomponents);

  /* check this if simage_read_image returns NULL or simage_write_image returns 0 */
  SIMAGE_DLL_API const char * simage_get_last_error(void);

  /* free resources allocated by either simage_read_image() or
     simage_resize() (Windows goes berzerk if you call free() from the
     client application) */
  SIMAGE_DLL_API void simage_free_image(unsigned char * imagedata);
  
  /* convenience function */
  SIMAGE_DLL_API int simage_next_power_of_two(int val);

  /* scale the input image and return a new image with the given dimensions */
  /* returned image buffer must be freed by simage_free_image() */
  SIMAGE_DLL_API unsigned char * simage_resize(unsigned char * imagedata,
                                                  int width, int height,
                                                  int numcomponents,
                                                  int newwidth, int newheight);

  /* use the plugin interface described below for extending simage to
     handle more file formats */

  struct simage_plugin 
  {
    unsigned char *(*load_func)(const char * name, int * width, int * height,
                                int * numcomponents);
    int (*identify_func)(const char * filename,
                         const unsigned char * header, int headerlen);
    int (*error_func)(char * textbuffer, int bufferlen);
  };

  SIMAGE_DLL_API void * simage_add_loader(const struct simage_plugin * l,
                                             int addbefore);
  SIMAGE_DLL_API void simage_remove_loader(void * handle);


  /*****************************************************************/
  /**** NOTE: new methods for simage version 1.1 *******************/
  /*****************************************************************/
  
  /* check if export is available for a filetype. Returns 1 if supported, 0 otherwise */
  SIMAGE_DLL_API int simage_check_save_supported(const char * filenameextension);
  
  /* save image. use simage_check_write_supported first, please */
  SIMAGE_DLL_API int simage_save_image(const char * filename,
                                          const unsigned char * bytes,
                                          int w, int h, int numcomponents,
                                          const char * filenameextension);
  
  SIMAGE_DLL_API void * simage_add_saver(int (*save_func)(const char * name,
                                                             const unsigned char * bytes,
                                                             int width, int height, int nc),
                                            int (*error_func)(char * textbuffer, int bufferlen),
                                            const char * extensions,
                                            const char * fullname,
                                            const char * description,
                                            int addbefore);
  
  SIMAGE_DLL_API void simage_remove_saver(void * handle);
  SIMAGE_DLL_API int simage_get_num_savers(void);
  SIMAGE_DLL_API void * simage_get_saver_handle(int idx);
  SIMAGE_DLL_API const char * simage_get_saver_extensions(void * handle);
  SIMAGE_DLL_API const char * simage_get_saver_fullname(void * handle);
  SIMAGE_DLL_API const char * simage_get_saver_description(void * handle);


  /*****************************************************************/
  /**** NOTE: new methods for simage version 1.2 *******************/
  /*****************************************************************/

  typedef struct simage_image_s s_image;
  typedef struct simage_movie_s s_movie;
  typedef struct simage_parameters_s s_params;
  typedef int s_movie_open_func(const char *, s_movie *);
  typedef int s_movie_create_func(const char *, s_movie *, s_params *);
  typedef s_image * s_movie_get_func(s_movie *, s_image *, s_params *);
  typedef int s_movie_put_func(s_movie *, s_image *, s_params *);
  typedef void s_movie_close_func(s_movie *);

  SIMAGE_DLL_API s_image * s_image_create(int w, int h, int components,
                                          unsigned char * prealloc /* | NULL */ );
  SIMAGE_DLL_API void s_image_destroy(s_image * image);
  
  SIMAGE_DLL_API int s_image_width(s_image * image);
  SIMAGE_DLL_API int s_image_height(s_image * image);
  SIMAGE_DLL_API int s_image_components(s_image * image);
  SIMAGE_DLL_API unsigned char * s_image_data(s_image * image);
  
  SIMAGE_DLL_API s_image * s_image_load(const char * filename, s_image * prealloc /* | NULL */);
  SIMAGE_DLL_API int s_image_save(const char * filename, s_image * image,
                                  s_params * params /* | NULL */);

  SIMAGE_DLL_API s_movie * s_movie_open(const char * filename);
  SIMAGE_DLL_API s_movie * s_movie_create(const char * filename, s_params * params /* | NULL */);
  SIMAGE_DLL_API s_image * s_movie_get_image(s_movie * movie, s_image * prealloc /* | NULL */,
                                             s_params * params /* | NULL */);
  SIMAGE_DLL_API int s_movie_put_image(s_movie * movie, s_image * image,
                                       s_params * params /* | NULL */);
  SIMAGE_DLL_API void s_movie_close(s_movie * movie);
  SIMAGE_DLL_API void s_movie_destroy(s_movie * movie);
  
  SIMAGE_DLL_API void s_movie_importer_add(s_movie_open_func * open,
                                           s_movie_get_func * get,
                                           s_movie_close_func * close);
  
  SIMAGE_DLL_API void s_movie_exporter_add(s_movie_create_func * create,
                                           s_movie_put_func * put,
                                           s_movie_close_func * close);

  enum {
    S_PARAM_END = 0,
    S_INTEGER_PARAM_TYPE,
    S_BOOL_PARAM_TYPE = S_INTEGER_PARAM_TYPE,
    S_FLOAT_PARAM_TYPE,
    S_DOUBLE_PARAM_TYPE,
    S_STRING_PARAM_TYPE,
    S_POINTER_PARAM_TYPE,
    S_FUNCTION_PARAM_TYPE
  };

  SIMAGE_DLL_API s_params * s_params_create(void);
  SIMAGE_DLL_API s_params * s_params_copy(s_params * params);
  SIMAGE_DLL_API void s_params_destroy(s_params * params);
  
  SIMAGE_DLL_API void s_params_set(s_params * params, ...);
  SIMAGE_DLL_API int s_params_get(s_params * params, ...);

#ifdef __cplusplus
}
#endif

#endif /* ! SIMAGE_H */
