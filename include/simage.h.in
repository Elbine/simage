#ifndef _SIMAGE_H_
#define _SIMAGE_H_

/*
 * simage:
 *
 * A simple library for loading images. This library is designed
 * for loading textures to be used as OpenGL textures. 
 * Only pixel formats directly supported by OpenGL (v1.0) will be 
 * returned. The user is responsible for resizing the texture to
 * a 2^n width/height though.
 *
 * This library does not support the "new" OpenGL v1.1 image
 * formats. In the future this might be supported though. We still
 * have some old SGI HW with only OpenGL v1.0 installed...
 *
 * Usage information:
 *
 * simage_check_supported(filename): 
 *
 *   Will return 1 if filename can be loaded, 0 otherwise. 
 *
 * simage_read_image(filename, width, height, numComponents)
 *
 *   Will (attempt to) read filename, and return a pointer to
 *   the image data. NULL is returned if the image could not
 *   be loaded. The memory is allocated using malloc(), and
 *   it is the callers responsibility to free the memory (using free())
 *   width and height contains the width and height of the image,
 *   and numComponents is a number indicating the following:
 *     1 : Grayscale image (GL_LUMINANCE)
 *     2 : Grayscale with alpha channel (GL_LUMINANCE_ALPHA)
 *     3 : RGB data (GL_RGB)
 *     4 : RGB data with alpha component (GL_RGBA)
 *
 * int simage_check_save_supported(const char * filenameextension)
 *    
 *   Returns 1 if a saver of type filenameextension is added. The
 *   built-in savers are jpg/jpeg, png, tif/tiff and rgb.
 *
 * int simage_save_image(const char * filename,
 *                       const unsigned char * bytes,
 *                       int w, int h, int numcomponents,
 *                       const char * filenameextension)
 *
 *   Saves image in the format specified in filenameextension.
 *
 * A couple of functions for your convenience:
 *
 * simage_resize(imagedata, width, height, numComponents,
 *               newwidth, newheight)
 *
 *   A convenience function that can be used to resize an image.
 *   Since OpenGL textures must have width and height equal to 2^n,
 *   this is often needed. A pointer to the new image data is returned. 
 *   imagedata is not freed. BTW: If you need a high quality resize 
 *   function, don't use this one :-) 
 *
 * simage_next_power_of_two(int val)
 * 
 *   Will return the first 2^n bigger or equal to val. 
 *   If simage_next_power_of_two(size) != size, you'll typically
 *   need to resize your image to be able to use it in an OpenGL app.
 */  

/* A unique identifier to recognize in sourcecode whether or not this
 * file is included.
 */
#define __SIMAGE__

/* These are available for adding or omitting features based on simage
 * version numbers in "client" sources. NB: they are automatically
 * synchronized with the settings in configure.in when configure is
 * run. The #ifndefs are necessary because during development, these
 * are also defined in the config.h file generated by configure.
 */
#if !defined(SIMAGE_MAJOR_VERSION)
#undef SIMAGE_MAJOR_VERSION
#endif /* !SIMAGE_MAJOR_VERSION */
#if !defined(SIMAGE_MINOR_VERSION)
#undef SIMAGE_MINOR_VERSION
#endif /* !SIMAGE_MINOR_VERSION */
#if !defined(SIMAGE_MICRO_VERSION)
#undef SIMAGE_MICRO_VERSION
#endif /* !SIMAGE_MICRO_VERSION */
#if !defined(SIMAGE_VERSION)
#undef SIMAGE_VERSION
#endif /* !SIMAGE_VERSION */



/* Enable to generate SIMAGE.DLL (under Win32). */
#ifdef SIMAGE_MAKE_DLL
#define SIMAGE_DLL_EXPORT __declspec(dllexport)
#endif /* !SIMAGE_MAKE_DLL */

/* Empty define to avoid errors when _not_ compiling as a DLL. */
#ifndef SIMAGE_DLL_EXPORT
#define SIMAGE_DLL_EXPORT
#endif /* !SIMAGE_DLL_EXPORT */


#ifdef __cplusplus
extern "C" {
#endif

  /* run-time version checking */
  SIMAGE_DLL_EXPORT void simage_version(int * major, int * minor, int * micro);

  /* check if image file format is supported */
  SIMAGE_DLL_EXPORT int simage_check_supported(const char * filename);

  /* reading and parsing image files */
  /* returned image buffer must be freed by simage_free_image() */
  SIMAGE_DLL_EXPORT unsigned char * simage_read_image(const char * filename,
						      int * w, int * h,
						      int * numcomponents);

  /* check if export is available for a filetype. Returns 1 if supported, 0 otherwise */
  SIMAGE_DLL_EXPORT int simage_check_save_supported(const char * filenameextension);
  
  /* save image. use simage_check_write_supported first, please */
  SIMAGE_DLL_EXPORT int simage_save_image(const char * filename,
                                          const unsigned char * bytes,
                                          int w, int h, int numcomponents,
                                          const char * filenameextension);
  
  /* check this if simage_read_image returns NULL or simage_write_image returns 0 */
  SIMAGE_DLL_EXPORT const char * simage_get_last_error(void);

  /* scale the input image and return a new image with the given dimensions */
  /* returned image buffer must be freed by simage_free_image() */
  SIMAGE_DLL_EXPORT unsigned char * simage_resize(unsigned char * imagedata,
						  int width, int height,
						  int numcomponents,
						  int newwidth, int newheight);

  /* free resources allocated by either simage_read_image() or
     simage_resize() (Windows goes berzerk if you call free() from the
     client application) */
  SIMAGE_DLL_EXPORT void simage_free_image(unsigned char * imagedata);
  
  /* convenience function */
  SIMAGE_DLL_EXPORT int simage_next_power_of_two(int val);


  /* use the plugin interface described below for extending simage to
     handle more file formats */

  struct simage_plugin 
  {
    unsigned char *(*load_func)(const char * name, int * width, int * height,
				int * numcomponents);
    int (*identify_func)(const char * filename,
			 const unsigned char * header, int headerlen);
    int (*error_func)(char * textbuffer, int bufferlen);
  };

  SIMAGE_DLL_EXPORT void * simage_add_loader(const struct simage_plugin * l,
                                             int addbefore);
  SIMAGE_DLL_EXPORT void simage_remove_loader(void * handle);
  
  SIMAGE_DLL_EXPORT void * simage_add_saver(int (*save_func)(const char * name,
                                                             const unsigned char * bytes,
                                                             int width, int height, int nc),
                                            int (*error_func)(char * textbuffer, int bufferlen),
                                            const char * extensions,
                                            const char * fullname,
                                            const char * description,
                                            int addbefore);
  
  SIMAGE_DLL_EXPORT void simage_remove_saver(void * handle);
  SIMAGE_DLL_EXPORT int simage_get_num_savers(void);
  SIMAGE_DLL_EXPORT void * simage_get_saver_handle(int idx);
  SIMAGE_DLL_EXPORT const char * simage_get_saver_extensions(void * handle);
  SIMAGE_DLL_EXPORT const char * simage_get_saver_fullname(void * handle);
  SIMAGE_DLL_EXPORT const char * simage_get_saver_description(void * handle);

#ifdef __cplusplus
}
#endif

#endif /* _SIMAGE_H_ */
